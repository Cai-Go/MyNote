# let 命令
ES6 新增了 **let** 命令来声明变量。

它的用法类似于 var，但是所声明的变量只能在 **let**命令所在的代码块内有效。

> 例子 

使用 var：
````js
	var a  = [];
	for(var i = 0; i < 10 ; i++){
		a[i]  = function(){
			console.log(i);
		};
	}
	a[6]();
````
上面代码中，变量 i 是 var 命令声明的，在全局范围内都有效，所以全局只有一个变量 i。每一次循环，变量 i 的值都会发生改变，而循环内被赋给数组 a 的函数内部的 console.log(i)，里面的 i 指向的就是全局的 i。也就是说，所有数组 a 的成员里面的 i，指向的都是同一个 i，导致运行时输出的是最后一轮的 i 的值，也就是 10。

使用 let :
````js
	var a = [];
	for(let i = 0; i<10; i++){
		a[i] = function(){
			console.log(i);
		};
	}
	a[6]();
````
上面代码中，变量 i 是 let 声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，所以最后输出的是 6。

for 循环的一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的自作用域。

let 不存在变量提升的问题，即所声明的变量一定要在声明后使用，否则报错。而 var 命令会发生变量提升的现象，即变量可以在声明之前使用，值为 undefined。

> 示例

````js
	//var 情况
	console.log(foo); // 输出 undefined
	var foo = 2;

	// let 的情况
	console.log(bar); // 报错ReferenceError
	let bar = 2;
````

只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
“暂时性死区”也意味着 typeof 不再是一个百分之百安全的操作。

let不允许在相同作用域内，重复声明同一个变量。

> 例子

````js
	// 报错
	function func() {
  		let a = 10;
  		var a = 1;
	}

	// 报错
	function func() {
  		let a = 10;
  		let a = 1;
	}
````
因此，不能在函数内部重新声明参数。

````js
	function func(arg) {
  		let arg; // 报错
	}

	function func(arg) {
  		{
   	 		let arg; // 不报错
  		}
	}
````
let 实际上为 JavaScript 新增了块级作用域。
ES6 允许块级作用域的任意嵌套，外层作用域无法读取内层作用域的变量；内层作用域可以定义外层作用域的同名变量；

ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
````js
	// 函数声明语句
	{
  		let a = 'secret';
  			function f() {
    		return a;
  		}
	}

	// 函数表达式
	{
  		let a = 'secret';
  		let f = function () {
    		return a;
  		};
	}
````

另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
````js
	// 不报错
	'use strict';
	if (true) {
  		function f() {}
	}

	// 报错
	'use strict';
	if (true)
  		function f() {}
````
